<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Flappy Bird</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: #4ec0ca;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }

        #gameContainer {
            position: relative;
            border: 3px solid #543847;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }

        canvas { display: block; }

        #overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.4);
            z-index: 10;
        }
        #overlay.hidden { display: none; }

        #overlay h1 {
            color: #fff; font-size: 36px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            margin-bottom: 10px;
        }
        #overlay p {
            color: #fff; font-size: 18px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            margin-bottom: 20px;
        }
        #overlay .score-display {
            color: #FFD700; font-size: 24px; font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            margin-bottom: 10px;
        }
        #overlay .word-display {
            color: #fff; font-size: 32px; font-weight: bold;
            letter-spacing: 4px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            margin-bottom: 20px;
            font-family: monospace;
        }

        #overlay button:not(.diff-btn) {
            padding: 12px 32px; font-size: 20px;
            background: #e8a43a; color: #fff;
            border: 3px solid #543847; border-radius: 12px;
            cursor: pointer; font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
            transition: transform 0.1s;
        }
        #overlay button:not(.diff-btn):hover { transform: scale(1.05); }
        #overlay button:not(.diff-btn):active { transform: scale(0.95); }

        /* Difficulty selector */
        .diff-wrap {
            display: flex; gap: 8px;
            margin-top: 14px;
        }
        .diff-btn {
            padding: 8px 14px; font-size: 14px; font-weight: bold;
            color: #fff; border: 2px solid rgba(255,255,255,0.35);
            border-radius: 10px; cursor: pointer;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
            transition: transform 0.1s, border-color 0.15s, background 0.15s;
            background: rgba(255,255,255,0.12);
        }
        .diff-btn:hover { transform: scale(1.06); }
        .diff-btn:active { transform: scale(0.94); }
        .diff-btn.active {
            border-color: #FFD700;
            background: rgba(255,215,0,0.25);
        }
        .diff-btn.easy   { color: #7fff7f; }
        .diff-btn.medium { color: #ffe066; }
        .diff-btn.hard   { color: #ff7f7f; }
        .diff-label {
            color: rgba(255,255,255,0.6); font-size: 13px;
            margin-top: 12px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.4);
        }

        /* ---- Full-screen screens ---- */
        .fullscreen {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            z-index: 100; cursor: pointer;
            touch-action: manipulation;
        }
        .fullscreen.hidden { display: none; }

        /* Welcome */
        #welcome {
            background: linear-gradient(135deg, #ff6b8a, #ff4571, #d63384);
        }
        .hearts {
            position: absolute; width: 100%; height: 100%;
            overflow: hidden; pointer-events: none;
        }
        .heart {
            position: absolute; font-size: 24px;
            animation: floatHeart linear infinite; opacity: 0.5;
        }
        @keyframes floatHeart {
            0%   { transform: translateY(100vh) rotate(0deg); opacity: 0; }
            10%  { opacity: 0.6; }
            90%  { opacity: 0.6; }
            100% { transform: translateY(-10vh) rotate(360deg); opacity: 0; }
        }
        .welcome-heart {
            font-size: 80px;
            animation: pulse 1.2s ease-in-out infinite;
            margin-bottom: 24px;
            filter: drop-shadow(0 4px 12px rgba(0,0,0,0.3));
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.15); }
        }
        .welcome-text {
            color: #fff; font-size: 28px; font-weight: bold;
            text-align: center;
            text-shadow: 2px 2px 8px rgba(0,0,0,0.3);
            padding: 0 24px; line-height: 1.5;
            max-width: 360px; margin-bottom: 32px;
        }
        .welcome-tap {
            color: rgba(255,255,255,0.85); font-size: 18px;
            text-shadow: 1px 1px 4px rgba(0,0,0,0.3);
            animation: tapPulse 2s ease-in-out infinite;
        }
        @keyframes tapPulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }

        /* Rules */
        #rules {
            background: linear-gradient(135deg, #667eea, #764ba2);
        }
        .rules-icon {
            font-size: 60px; margin-bottom: 20px;
        }
        .rules-title {
            color: #FFD700; font-size: 26px; font-weight: bold;
            text-shadow: 2px 2px 6px rgba(0,0,0,0.4);
            margin-bottom: 24px;
        }
        .rules-text {
            color: #fff; font-size: 18px;
            text-align: center; line-height: 1.7;
            padding: 0 28px; max-width: 360px;
            text-shadow: 1px 1px 4px rgba(0,0,0,0.3);
            margin-bottom: 16px;
        }
        .rules-word-preview {
            font-family: monospace;
            font-size: 30px; font-weight: bold;
            letter-spacing: 6px; color: #FFD700;
            text-shadow: 2px 2px 6px rgba(0,0,0,0.4);
            margin-bottom: 28px;
        }
        .rules-btn {
            padding: 14px 40px; font-size: 22px;
            background: #ff4571; color: #fff;
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 14px; cursor: pointer;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
            transition: transform 0.1s;
        }
        .rules-btn:hover { transform: scale(1.05); }
        .rules-btn:active { transform: scale(0.95); }

        /* Word complete screen */
        #wordComplete {
            background: linear-gradient(135deg, #f093fb, #f5576c, #ff6b8a);
        }
        .wc-icon { font-size: 70px; margin-bottom: 16px; }
        .wc-title {
            color: #FFD700; font-size: 30px; font-weight: bold;
            text-shadow: 2px 2px 6px rgba(0,0,0,0.4);
            margin-bottom: 12px;
        }
        .wc-word {
            font-family: monospace;
            font-size: 36px; font-weight: bold;
            letter-spacing: 6px; color: #fff;
            text-shadow: 2px 2px 6px rgba(0,0,0,0.4);
            margin-bottom: 8px;
            animation: pulse 1.5s ease-in-out infinite;
        }
        .wc-stats {
            color: rgba(255,255,255,0.9); font-size: 18px;
            text-shadow: 1px 1px 4px rgba(0,0,0,0.3);
            margin-bottom: 24px;
        }
    </style>
</head>
<body>
    <!-- Welcome screen -->
    <div id="welcome" class="fullscreen">
        <div class="hearts" id="heartsContainer"></div>
        <div class="welcome-heart">&#127918;</div>
        <div class="welcome-text">Flappy Bird: &#1059;&#1075;&#1072;&#1076;&#1072;&#1081; &#1089;&#1083;&#1086;&#1074;&#1086;!</div>
        <div class="welcome-tap">&#1058;&#1072;&#1087;&#1085;&#1080; &#1095;&#1090;&#1086;&#1073;&#1099; &#1085;&#1072;&#1095;&#1072;&#1090;&#1100; &#128071;</div>
    </div>

    <!-- Rules screen -->
    <div id="rules" class="fullscreen hidden">
        <div class="rules-icon">&#127918;</div>
        <div class="rules-title">&#1050;&#1072;&#1082; &#1080;&#1075;&#1088;&#1072;&#1090;&#1100;?</div>
        <div class="rules-text">
            &#1054;&#1090;&#1082;&#1088;&#1099;&#1074;&#1072;&#1081; &#1089;&#1083;&#1086;&#1074;&#1072; &#1086;&#1076;&#1085;&#1086; &#1079;&#1072; &#1076;&#1088;&#1091;&#1075;&#1080;&#1084;!<br><br>
            &#1053;&#1072;&#1073;&#1080;&#1088;&#1072;&#1081; &#1086;&#1095;&#1082;&#1080; &#1095;&#1090;&#1086;&#1073;&#1099; &#1086;&#1090;&#1082;&#1088;&#1099;&#1090;&#1100; &#1073;&#1091;&#1082;&#1074;&#1099;.<br>
            &#1059;&#1087;&#1072;&#1083; &#8212; &#1089;&#1095;&#1105;&#1090; &#1089;&#1073;&#1088;&#1072;&#1089;&#1099;&#1074;&#1072;&#1077;&#1090;&#1089;&#1103;, &#1085;&#1086; &#1073;&#1091;&#1082;&#1074;&#1099; &#1086;&#1089;&#1090;&#1072;&#1102;&#1090;&#1089;&#1103;!
        </div>
        <div class="rules-word-preview" id="rulesWordPreview"></div>
        <button class="rules-btn" id="rulesBtn">&#1053;&#1072;&#1095;&#1072;&#1090;&#1100;! &#128293;</button>
    </div>

    <!-- Word complete screen -->
    <div id="wordComplete" class="fullscreen hidden">
        <div class="hearts" id="wcHeartsContainer"></div>
        <div class="wc-icon">&#127881;&#11088;&#127881;</div>
        <div class="wc-title">&#1057;&#1083;&#1086;&#1074;&#1086; &#1086;&#1090;&#1082;&#1088;&#1099;&#1090;&#1086;!</div>
        <div class="wc-word" id="wcWord"></div>
        <div class="wc-stats" id="wcStats"></div>
        <button class="rules-btn" id="nextWordBtn">&#1057;&#1083;&#1077;&#1076;&#1091;&#1102;&#1097;&#1077;&#1077; &#1089;&#1083;&#1086;&#1074;&#1086; &#128640;</button>
    </div>

    <!-- Game -->
    <div id="gameContainer">
        <canvas id="game"></canvas>
        <div id="overlay">
            <h1>Flappy Bird</h1>
            <p id="overlayText">&#1058;&#1072;&#1087;&#1085;&#1080; &#1095;&#1090;&#1086;&#1073;&#1099; &#1083;&#1077;&#1090;&#1077;&#1090;&#1100;</p>
            <div class="word-display" id="overlayWord"></div>
            <div class="score-display hidden" id="finalScore"></div>
            <button id="startBtn">&#1048;&#1075;&#1088;&#1072;&#1090;&#1100;</button>
            <div class="diff-label">&#1057;&#1083;&#1086;&#1078;&#1085;&#1086;&#1089;&#1090;&#1100;:</div>
            <div class="diff-wrap">
                <button class="diff-btn easy active" data-diff="5">&#1051;&#1105;&#1075;&#1082;&#1086;</button>
                <button class="diff-btn medium" data-diff="10">&#1057;&#1088;&#1077;&#1076;&#1085;&#1077;</button>
                <button class="diff-btn hard" data-diff="15">&#1058;&#1103;&#1078;&#1077;&#1083;&#1086;</button>
            </div>
        </div>
    </div>

    <script>
    // ---- Word list ----
    const WORDS = [
        'КОШКА', 'СОБАКА', 'СОЛНЦЕ', 'ДЕРЕВО', 'ОБЛАКО', 'РАКЕТА', 'ЗВЕЗДА', 'МЕДВЕДЬ',
        'БАБОЧКА', 'РАДУГА', 'МОРОЗ', 'ОКЕАН', 'ДОЖДЬ', 'ВЕТЕР', 'ЛУНА', 'ОГОНЬ',
        'ГОРЫ', 'РЕКА', 'ЗАМОК', 'РЫЦАРЬ', 'ДРАКОН', 'ПРИНЦ', 'КНИГА', 'МУЗЫКА',
        'ТАНЕЦ', 'ПИРОГ', 'КОФЕ', 'ЗАКАТ', 'РАССВЕТ', 'СКАЗКА', 'МЕЧТА', 'УДАЧА',
        'ЦВЕТОК', 'ФОНАРЬ', 'МАЯК', 'ПЕСНЯ', 'ИСКРА', 'ВУЛКАН', 'КОМЕТА', 'КОМПАС',
        'МОЛНИЯ', 'ТАЙНА', 'ПЛАМЯ', 'НОЧЬ', 'УТРО', 'ВЕСНА', 'ЛЕТО', 'ОСЕНЬ',
        'ЗИМА', 'МЕТЕЛЬ', 'РУЧЕЙ', 'ОСТРОВ', 'ВОЛНА', 'ПАРУС', 'ШТОРМ', 'НЕБО',
        'ПОЕЗД', 'БАЛКОН', 'ФАКЕЛ', 'РЫБКА', 'ПТИЦА', 'ПИНГВИН', 'ЖИРАФ', 'ТИГР',
        'ПИРАТ', 'РОБОТ', 'АЛМАЗ', 'МАГИЯ', 'ЗЕЛЬЕ', 'ПОРТАЛ', 'КОСМОС', 'ПЛАНЕТА',
        'ГАЛАКТИКА', 'ЗАГАДКА', 'ЧУДО', 'ПОБЕДА', 'ГЕРОЙ', 'РЕКОРД', 'ФИНИШ', 'СТАРТ'
    ];

    function pickRandomWord() {
        return WORDS[Math.floor(Math.random() * WORDS.length)];
    }

    // ---- Difficulty & current word state ----
    let pointsPerLetter = 5;
    let currentWord = pickRandomWord();
    let letterIndices = [];
    let totalLetters = 0;
    let revealOrder = [];
    let revealedSet = new Set();
    let revealedCount = 0;
    let wordsCompleted = 0;
    let bestWords = parseInt(localStorage.getItem('flappyBestWords') || '0');

    function setupWord(word) {
        currentWord = word;
        letterIndices = [];
        word.split('').forEach((ch, i) => { if (ch !== ' ') letterIndices.push(i); });
        totalLetters = letterIndices.length;
        revealOrder = [...letterIndices];
        for (let i = revealOrder.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [revealOrder[i], revealOrder[j]] = [revealOrder[j], revealOrder[i]];
        }
        revealedSet = new Set();
        revealedCount = 0;
    }

    setupWord(currentWord);

    function getWordDisplay() {
        return currentWord.split('').map((ch, i) => {
            if (ch === ' ') return '  ';
            return revealedSet.has(i) ? ch : '_';
        }).join(' ');
    }

    function getNextThreshold() {
        return (revealedCount + 1) * pointsPerLetter;
    }

    // ---- Welcome screen ----
    (function() {
        const container = document.getElementById('heartsContainer');
        const emojis = ['\u2764\ufe0f', '\uD83D\uDC95', '\uD83D\uDC96', '\uD83D\uDC97', '\uD83D\uDC98', '\uD83D\uDC9D'];
        for (let i = 0; i < 20; i++) {
            const h = document.createElement('div');
            h.className = 'heart';
            h.textContent = emojis[Math.floor(Math.random() * emojis.length)];
            h.style.left = Math.random() * 100 + '%';
            h.style.fontSize = (16 + Math.random() * 24) + 'px';
            h.style.animationDuration = (4 + Math.random() * 6) + 's';
            h.style.animationDelay = (Math.random() * 5) + 's';
            container.appendChild(h);
        }

        const welcome = document.getElementById('welcome');
        function showRules() {
            welcome.classList.add('hidden');
            document.getElementById('rules').classList.remove('hidden');
        }
        welcome.addEventListener('click', showRules);
        welcome.addEventListener('touchstart', function(e) { e.preventDefault(); showRules(); });
    })();

    // ---- Word complete screen stars ----
    (function() {
        const container = document.getElementById('wcHeartsContainer');
        const emojis = ['\u2B50', '\uD83C\uDF1F', '\u2728', '\uD83D\uDCAB', '\uD83C\uDF89', '\uD83C\uDF8A'];
        for (let i = 0; i < 20; i++) {
            const h = document.createElement('div');
            h.className = 'heart';
            h.textContent = emojis[Math.floor(Math.random() * emojis.length)];
            h.style.left = Math.random() * 100 + '%';
            h.style.fontSize = (16 + Math.random() * 24) + 'px';
            h.style.animationDuration = (4 + Math.random() * 6) + 's';
            h.style.animationDelay = (Math.random() * 5) + 's';
            container.appendChild(h);
        }
    })();

    // ---- Game ----
    (function() {
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const overlay = document.getElementById('overlay');
        const overlayText = document.getElementById('overlayText');
        const overlayWord = document.getElementById('overlayWord');
        const finalScore = document.getElementById('finalScore');
        const startBtn = document.getElementById('startBtn');
        const rulesBtn = document.getElementById('rulesBtn');

        const MAX_W = 400, MAX_H = 600;
        let W, H, scale;

        function resize() {
            const vw = window.innerWidth;
            const vh = window.innerHeight;
            scale = Math.min(vw / MAX_W, vh / MAX_H, 1);
            W = Math.floor(MAX_W * scale);
            H = Math.floor(MAX_H * scale);
            canvas.width = W;
            canvas.height = H;
        }
        resize();
        window.addEventListener('resize', resize);

        const s = () => scale;
        const GRAVITY = 0.45;
        const FLAP_FORCE = -7.5;
        const PIPE_WIDTH = 72;
        const PIPE_GAP = 170;
        const PIPE_SPEED = 2.2;
        const PIPE_SPAWN = 160;
        const BIRD_SIZE = 22;
        const GROUND_H = 60;

        let bird, pipes, score, gameState, frame, groundX;
        let particles = [];
        let birdHue = 30; // random hue for the bird, set on each init

        function hsl(h, sat, light) {
            return `hsl(${h}, ${sat}%, ${light}%)`;
        }

        function spawnParticles(x, y, isLetter) {
            const count = isLetter ? 24 : 12;
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = (2 + Math.random() * 4) * s();
                const isHeart = Math.random() < 0.5;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed - 2 * s(),
                    life: 1.0,
                    decay: 0.008 + Math.random() * 0.008,
                    size: (isHeart ? 14 : 8) + Math.random() * 8,
                    type: isHeart ? 'heart' : 'sparkle',
                    color: isHeart
                        ? ['#ff4571','#ff6b8a','#d63384','#ff85a1'][Math.floor(Math.random()*4)]
                        : ['#FFD700','#FFF','#ffec80','#ffd0e8'][Math.floor(Math.random()*4)],
                    rotation: Math.random() * Math.PI * 2,
                    rotSpeed: (Math.random() - 0.5) * 0.2
                });
            }
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const pt = particles[i];
                pt.x += pt.vx;
                pt.y += pt.vy;
                pt.vy += 0.1 * s();
                pt.vx *= 0.99;
                pt.life -= pt.decay;
                pt.rotation += pt.rotSpeed;
                if (pt.life <= 0) particles.splice(i, 1);
            }
        }

        function drawParticles() {
            for (const pt of particles) {
                ctx.save();
                ctx.globalAlpha = Math.max(0, pt.life);
                ctx.translate(pt.x, pt.y);
                ctx.rotate(pt.rotation);
                const sz = pt.size * s() * (0.5 + pt.life * 0.5);

                if (pt.type === 'heart') {
                    // Simple heart shape
                    ctx.fillStyle = pt.color;
                    ctx.font = `${Math.round(sz)}px serif`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('\u2764', 0, 0);
                } else {
                    // Sparkle: filled circle with glow
                    ctx.fillStyle = pt.color;
                    ctx.shadowColor = pt.color;
                    ctx.shadowBlur = sz * 0.8;
                    ctx.beginPath();
                    ctx.arc(0, 0, sz * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }

                ctx.restore();
            }
        }

        function init() {
            bird = { x: W * 0.28, y: H * 0.45, vy: 0, rotation: 0, flapFrame: 0 };
            pipes = [];
            particles = [];
            score = 0;
            frame = 0;
            groundX = 0;
            gameState = 'ready';
            birdHue = Math.floor(Math.random() * 360);
        }

        function flap() {
            if (gameState === 'dead') return;
            if (gameState === 'ready') {
                gameState = 'playing';
                overlay.classList.add('hidden');
            }
            bird.vy = FLAP_FORCE * s();
            bird.flapFrame = frame;
        }

        function spawnPipe() {
            const minY = 80 * s();
            const maxY = H - GROUND_H * s() - PIPE_GAP * s() - minY;
            const topH = minY + Math.random() * maxY;
            pipes.push({ x: W + 10, topH, scored: false });
        }

        function showWordComplete() {
            gameState = 'wordComplete';
            wordsCompleted++;
            if (wordsCompleted > bestWords) {
                bestWords = wordsCompleted;
                localStorage.setItem('flappyBestWords', String(bestWords));
            }
            document.getElementById('wcWord').textContent = currentWord;
            document.getElementById('wcStats').textContent =
                '\u0421\u043b\u043e\u0432: ' + wordsCompleted + ' | \u0420\u0435\u043a\u043e\u0440\u0434: ' + bestWords;
            document.getElementById('wordComplete').classList.remove('hidden');
        }

        function update() {
            if (gameState !== 'playing') return;
            frame++;

            bird.vy += GRAVITY * s();
            bird.y += bird.vy;

            if (bird.vy < 0) bird.rotation = Math.max(-0.5, bird.vy * 0.08);
            else bird.rotation = Math.min(1.2, bird.vy * 0.06);

            const groundY = H - GROUND_H * s();
            if (bird.y + BIRD_SIZE * s() > groundY) {
                bird.y = groundY - BIRD_SIZE * s();
                die(); return;
            }
            if (bird.y < 0) { bird.y = 0; bird.vy = 0; }

            if (frame % Math.floor(PIPE_SPAWN / (PIPE_SPEED * s())) === 0) spawnPipe();

            const bx = bird.x, by = bird.y;
            const bs = BIRD_SIZE * s();
            const pw = PIPE_WIDTH * s();
            const pg = PIPE_GAP * s();

            for (let i = pipes.length - 1; i >= 0; i--) {
                const p = pipes[i];
                p.x -= PIPE_SPEED * s();

                if (p.x + pw < 0) { pipes.splice(i, 1); continue; }

                if (!p.scored && p.x + pw < bx) {
                    p.scored = true;
                    score++;
                    const birdCx = bird.x + bs / 2;
                    const birdCy = bird.y + bs / 2;
                    spawnParticles(birdCx, birdCy, false);
                    // Reveal a letter every 5 points
                    if (revealedCount < totalLetters && score === getNextThreshold()) {
                        spawnParticles(birdCx, birdCy, true);
                        const pos = revealOrder[revealedCount];
                        revealedSet.add(pos);
                        revealedCount = revealedSet.size;
                        if (revealedCount >= totalLetters) {
                            showWordComplete();
                            return;
                        }
                    }
                }

                const margin = 3 * s();
                if (bx + bs - margin > p.x && bx + margin < p.x + pw) {
                    if (by + margin < p.topH || by + bs - margin > p.topH + pg) {
                        die(); return;
                    }
                }
            }

            groundX -= PIPE_SPEED * s();
            if (groundX <= -24 * s()) groundX = 0;

            updateParticles();
        }

        function die() {
            gameState = 'dead';
            overlay.classList.remove('hidden');
            overlayText.textContent = 'Game Over';
            overlayWord.textContent = getWordDisplay();
            const left = totalLetters - revealedCount;
            if (left > 0) {
                finalScore.textContent = '\u0421\u0447\u0451\u0442: ' + score + ' | \u0421\u043b\u0435\u0434. \u0431\u0443\u043a\u0432\u0430: ' + getNextThreshold() + ' \u043e\u0447\u043a\u043e\u0432';
            } else {
                finalScore.textContent = '\u0412\u0441\u0435 \u0431\u0443\u043a\u0432\u044b \u043e\u0442\u043a\u0440\u044b\u0442\u044b!';
            }
            finalScore.classList.remove('hidden');
            if (wordsCompleted > 0) {
                startBtn.textContent = '\u0415\u0449\u0451 \u0440\u0430\u0437 (\u0441\u043b\u043e\u0432: ' + wordsCompleted + ')';
            } else {
                startBtn.textContent = '\u0415\u0449\u0451 \u0440\u0430\u0437';
            }
        }

        // Drawing
        function drawBackground() {
            const grd = ctx.createLinearGradient(0, 0, 0, H);
            grd.addColorStop(0, '#4ec0ca');
            grd.addColorStop(1, '#71c8d6');
            ctx.fillStyle = grd;
            ctx.fillRect(0, 0, W, H);
            ctx.fillStyle = 'rgba(255,255,255,0.6)';
            drawCloud(50*s(), 80*s(), 40*s());
            drawCloud(200*s(), 50*s(), 30*s());
            drawCloud(320*s(), 110*s(), 35*s());
        }
        function drawCloud(x, y, r) {
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI*2);
            ctx.arc(x+r*0.8, y-r*0.3, r*0.7, 0, Math.PI*2);
            ctx.arc(x+r*1.4, y, r*0.6, 0, Math.PI*2);
            ctx.fill();
        }
        function drawVapeBody(x, y, w, h, flipped) {
            // Main body - dark gradient
            const grd = ctx.createLinearGradient(x, y, x + w, y);
            grd.addColorStop(0, '#2a2a2e');
            grd.addColorStop(0.3, '#3d3d42');
            grd.addColorStop(0.5, '#4a4a50');
            grd.addColorStop(0.7, '#3d3d42');
            grd.addColorStop(1, '#2a2a2e');
            ctx.fillStyle = grd;

            const r = 8 * s();
            ctx.beginPath();
            ctx.roundRect(x, y, w, h, r);
            ctx.fill();

            // Side highlight
            ctx.fillStyle = 'rgba(255,255,255,0.08)';
            ctx.fillRect(x + 4*s(), y + r, 6*s(), h - r*2);

            // Screen area
            const scrW = w * 0.5;
            const scrH = Math.min(28 * s(), h * 0.15);
            const scrX = x + (w - scrW) / 2;
            const scrY = flipped ? y + h - scrH - 14*s() : y + 14*s();

            ctx.fillStyle = '#111';
            ctx.beginPath();
            ctx.roundRect(scrX, scrY, scrW, scrH, 3*s());
            ctx.fill();

            // Screen glow
            ctx.fillStyle = '#00e5ff';
            ctx.globalAlpha = 0.6;
            ctx.beginPath();
            ctx.roundRect(scrX + 2*s(), scrY + 2*s(), scrW - 4*s(), scrH - 4*s(), 2*s());
            ctx.fill();
            ctx.globalAlpha = 1;

            // Battery bar on screen
            ctx.fillStyle = '#00ff88';
            ctx.fillRect(scrX + 4*s(), scrY + scrH * 0.35, (scrW - 8*s()) * 0.7, scrH * 0.3);

            // WAKA text
            ctx.fillStyle = 'rgba(255,255,255,0.25)';
            ctx.font = `bold ${9*s()}px Arial`;
            ctx.textAlign = 'center';
            const textY = flipped ? scrY - 8*s() : scrY + scrH + 14*s();
            ctx.fillText('WAKA', x + w/2, textY);
        }

        function drawMouthpiece(x, y, w, h, flipped) {
            // Mouthpiece - tapered top piece
            const mpW = w * 0.6;
            const mpH = Math.min(18 * s(), h);
            const mpX = x + (w - mpW) / 2;
            const mpY = flipped ? y + h - mpH : y;

            const grd = ctx.createLinearGradient(mpX, mpY, mpX + mpW, mpY);
            grd.addColorStop(0, '#1a1a1e');
            grd.addColorStop(0.5, '#333338');
            grd.addColorStop(1, '#1a1a1e');
            ctx.fillStyle = grd;

            ctx.beginPath();
            ctx.roundRect(mpX, mpY, mpW, mpH, 4*s());
            ctx.fill();
        }

        function drawPipe(p) {
            const pw = PIPE_WIDTH * s();
            const pg = PIPE_GAP * s();

            // Top vape (flipped, mouthpiece pointing down)
            const topH = p.topH;
            if (topH > 20*s()) {
                const mpZone = Math.min(18*s(), topH * 0.15);
                drawVapeBody(p.x, 0, pw, topH - mpZone, true);
                drawMouthpiece(p.x, topH - mpZone, pw, mpZone, false);
            }

            // Bottom vape (normal, mouthpiece pointing up)
            const botY = p.topH + pg;
            const botH = H - botY;
            if (botH > 20*s()) {
                const mpZone = Math.min(18*s(), botH * 0.15);
                drawMouthpiece(p.x, botY, pw, mpZone, false);
                drawVapeBody(p.x, botY + mpZone, pw, botH - mpZone, false);
            }
        }
        function drawBird() {
            const bs = BIRD_SIZE * s();
            const cx = bird.x + bs / 2;
            const cy = bird.y + bs / 2;

            ctx.save();
            ctx.translate(cx, cy);
            ctx.rotate(bird.rotation * 0.6);

            const r = bs * 0.9; // base radius

            // Bird colors from random hue
            const bodyColor = hsl(birdHue, 60, 88);
            const puffColor = hsl(birdHue, 50, 82);
            const headPuffColor = hsl(birdHue, 45, 92);
            const earColor = hsl(birdHue, 55, 80);

            // --- Fluffy body (behind head) ---
            ctx.fillStyle = bodyColor;
            ctx.beginPath();
            ctx.ellipse(0, r * 0.35, r * 0.65, r * 0.55, 0, 0, Math.PI * 2);
            ctx.fill();

            // Body fluff puffs
            ctx.fillStyle = puffColor;
            const bodyPuffs = [[-r*0.35, r*0.2, r*0.28], [r*0.3, r*0.25, r*0.25], [0, r*0.55, r*0.3]];
            for (const [px, py, pr] of bodyPuffs) {
                ctx.beginPath(); ctx.arc(px, py, pr, 0, Math.PI * 2); ctx.fill();
            }

            // --- Tail (small fluff) ---
            ctx.fillStyle = bodyColor;
            ctx.beginPath();
            ctx.arc(-r * 0.6, r * 0.1, r * 0.22, 0, Math.PI * 2);
            ctx.fill();

            // --- Floppy ears ---
            // Left ear
            ctx.fillStyle = earColor;
            ctx.beginPath();
            ctx.ellipse(-r * 0.55, -r * 0.1, r * 0.22, r * 0.4, 0.3, 0, Math.PI * 2);
            ctx.fill();
            // Ear fluff
            ctx.fillStyle = bodyColor;
            ctx.beginPath();
            ctx.arc(-r * 0.48, -r * 0.2, r * 0.12, 0, Math.PI * 2);
            ctx.fill();

            // Right ear
            ctx.fillStyle = earColor;
            ctx.beginPath();
            ctx.ellipse(r * 0.55, -r * 0.1, r * 0.22, r * 0.4, -0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = bodyColor;
            ctx.beginPath();
            ctx.arc(r * 0.48, -r * 0.2, r * 0.12, 0, Math.PI * 2);
            ctx.fill();

            // --- Head (fluffy circle) ---
            ctx.fillStyle = bodyColor;
            ctx.beginPath();
            ctx.arc(0, -r * 0.1, r * 0.55, 0, Math.PI * 2);
            ctx.fill();

            // Fluffy puffs around head
            ctx.fillStyle = headPuffColor;
            const puffs = [
                [-r*0.35, -r*0.35, r*0.2],
                [r*0.35, -r*0.35, r*0.2],
                [-r*0.42, -r*0.05, r*0.18],
                [r*0.42, -r*0.05, r*0.18],
                [0, -r*0.52, r*0.2],
                [-r*0.2, -r*0.48, r*0.16],
                [r*0.2, -r*0.48, r*0.16]
            ];
            for (const [px, py, pr] of puffs) {
                ctx.beginPath();
                ctx.arc(px, py, pr, 0, Math.PI * 2);
                ctx.fill();
            }

            // --- Eyes ---
            // White
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(-r * 0.18, -r * 0.18, r * 0.15, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(r * 0.18, -r * 0.18, r * 0.15, 0, Math.PI * 2);
            ctx.fill();

            // Pupils
            ctx.fillStyle = '#2c1810';
            ctx.beginPath();
            ctx.arc(-r * 0.15, -r * 0.18, r * 0.1, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(r * 0.21, -r * 0.18, r * 0.1, 0, Math.PI * 2);
            ctx.fill();

            // Eye shine
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(-r * 0.12, -r * 0.22, r * 0.04, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(r * 0.24, -r * 0.22, r * 0.04, 0, Math.PI * 2);
            ctx.fill();

            // --- Nose ---
            ctx.fillStyle = '#2c1810';
            ctx.beginPath();
            ctx.ellipse(r * 0.03, -r * 0.02, r * 0.08, r * 0.06, 0, 0, Math.PI * 2);
            ctx.fill();

            // Nose shine
            ctx.fillStyle = 'rgba(255,255,255,0.4)';
            ctx.beginPath();
            ctx.arc(r * 0.01, -r * 0.04, r * 0.025, 0, Math.PI * 2);
            ctx.fill();

            // --- Mouth ---
            ctx.strokeStyle = '#5a3825';
            ctx.lineWidth = 1.2 * s();
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(r * 0.03, r * 0.03);
            ctx.quadraticCurveTo(r * -0.08, r * 0.12, r * -0.15, r * 0.08);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(r * 0.03, r * 0.03);
            ctx.quadraticCurveTo(r * 0.14, r * 0.12, r * 0.22, r * 0.08);
            ctx.stroke();

            // --- Tongue (when flapping) ---
            if (bird.vy < -2 * s()) {
                ctx.fillStyle = '#ff8fa3';
                ctx.beginPath();
                ctx.ellipse(r * 0.03, r * 0.1, r * 0.06, r * 0.08, 0, 0, Math.PI);
                ctx.fill();
            }

            ctx.restore();
        }
        function drawGround() {
            const gH = GROUND_H*s(), gY = H-gH;
            ctx.fillStyle = '#ded895'; ctx.fillRect(0, gY, W, gH);
            ctx.fillStyle = '#d2b34a'; ctx.fillRect(0, gY, W, 4*s());
            ctx.fillStyle = '#8bc34a';
            const tW = 24*s();
            for (let x = groundX; x < W+tW; x += tW) {
                ctx.beginPath(); ctx.moveTo(x, gY); ctx.lineTo(x+tW*0.5, gY-6*s()); ctx.lineTo(x+tW, gY); ctx.fill();
            }
        }

        function drawScore() {
            if (gameState !== 'playing') return;
            const text = String(score);
            ctx.font = `bold ${32*s()}px Arial`;
            ctx.textAlign = 'center';
            ctx.strokeStyle = '#543847'; ctx.lineWidth = 4*s();
            ctx.strokeText(text, W/2, 50*s());
            ctx.fillStyle = '#fff';
            ctx.fillText(text, W/2, 50*s());
        }

        function drawWordBar() {
            if (gameState !== 'playing') return;
            const barH = 40 * s();
            const barY = H - GROUND_H*s() - barH;
            ctx.fillStyle = 'rgba(0,0,0,0.35)';
            ctx.fillRect(0, barY, W, barH);

            // Word
            const display = getWordDisplay();
            ctx.font = `bold ${15*s()}px monospace`;
            ctx.textAlign = 'center';
            ctx.fillStyle = '#FFD700';
            ctx.fillText(display, W/2, barY + 16*s());

            // Next letter hint
            if (revealedCount < totalLetters) {
                const next = getNextThreshold();
                ctx.font = `${11*s()}px Arial`;
                ctx.fillStyle = 'rgba(255,255,255,0.7)';
                ctx.fillText('\u0421\u043b\u0435\u0434. \u0431\u0443\u043a\u0432\u0430: ' + next + ' \u043e\u0447\u043a\u043e\u0432 | \u0421\u043b\u043e\u0432: ' + wordsCompleted, W/2, barY + 32*s());
            }
        }

        function drawReadyHint() {
            if (gameState !== 'ready') return;
            bird.y = H*0.45 + Math.sin(Date.now()*0.004)*8*s();
        }

        function draw() {
            drawBackground();
            pipes.forEach(drawPipe);
            drawGround();
            drawReadyHint();
            drawBird();
            drawParticles();
            drawScore();
            drawWordBar();
        }

        function loop() {
            update();
            draw();
            requestAnimationFrame(loop);
        }

        // Input
        function handleInput(e) {
            e.preventDefault();
            if (gameState === 'dead') return;
            flap();
        }
        canvas.addEventListener('pointerdown', handleInput);
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' || e.code === 'ArrowUp') {
                e.preventDefault();
                if (gameState === 'dead') return;
                flap();
            }
        });

        startBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            init();
            overlay.classList.add('hidden');
            overlayWord.textContent = '';
            finalScore.classList.add('hidden');
            gameState = 'ready';
        });

        rulesBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            document.getElementById('rules').classList.add('hidden');
            init();
            overlayWord.textContent = getWordDisplay();
        });

        document.getElementById('nextWordBtn').addEventListener('click', (e) => {
            e.stopPropagation();
            document.getElementById('wordComplete').classList.add('hidden');
            setupWord(pickRandomWord());
            init();
            overlayWord.textContent = getWordDisplay();
        });

        // Difficulty buttons
        const diffBtns = document.querySelectorAll('.diff-btn');
        diffBtns.forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                const newPPL = parseInt(btn.dataset.diff);
                if (newPPL === pointsPerLetter) return;
                // Switch active style
                diffBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                // If letters were already revealed, reset word
                if (revealedCount > 0) {
                    setupWord(pickRandomWord());
                }
                pointsPerLetter = newPPL;
                overlayWord.textContent = getWordDisplay();
            });
        });

        // Prevent scroll on mobile
        document.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });

        // Set rules preview
        document.getElementById('rulesWordPreview').textContent = getWordDisplay();

        init();
        overlayWord.textContent = getWordDisplay();
        loop();
    })();
    </script>
</body>
</html>
